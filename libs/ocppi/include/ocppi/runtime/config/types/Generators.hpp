// Thish file is generated by /tools/codegen
// DO NOT EDIT IT.

// clang-format off

//  To parse this JSON data, first install
//
//      json.hpp  https://github.com/nlohmann/json
//
//  Then include this file, and then do
//
//     Generators.hpp data = nlohmann::json::parse(jsonString);

#pragma once

#include <optional>
#include <nlohmann/json.hpp>
#include "ocppi/runtime/config/types/helper.hpp"

#include "ocppi/runtime/config/types/Config.hpp"
#include "ocppi/runtime/config/types/Zos.hpp"
#include "ocppi/runtime/config/types/ZosDevice.hpp"
#include "ocppi/runtime/config/types/Windows.hpp"
#include "ocppi/runtime/config/types/WindowsResources.hpp"
#include "ocppi/runtime/config/types/Storage.hpp"
#include "ocppi/runtime/config/types/FluffyMemory.hpp"
#include "ocppi/runtime/config/types/FluffyCPU.hpp"
#include "ocppi/runtime/config/types/WindowsNetwork.hpp"
#include "ocppi/runtime/config/types/Hyperv.hpp"
#include "ocppi/runtime/config/types/WindowsDevice.hpp"
#include "ocppi/runtime/config/types/IdType.hpp"
#include "ocppi/runtime/config/types/Vm.hpp"
#include "ocppi/runtime/config/types/Kernel.hpp"
#include "ocppi/runtime/config/types/Image.hpp"
#include "ocppi/runtime/config/types/RootImageFormat.hpp"
#include "ocppi/runtime/config/types/Hypervisor.hpp"
#include "ocppi/runtime/config/types/Solaris.hpp"
#include "ocppi/runtime/config/types/CappedMemory.hpp"
#include "ocppi/runtime/config/types/CappedCPU.hpp"
#include "ocppi/runtime/config/types/Anet.hpp"
#include "ocppi/runtime/config/types/Root.hpp"
#include "ocppi/runtime/config/types/Process.hpp"
#include "ocppi/runtime/config/types/User.hpp"
#include "ocppi/runtime/config/types/Scheduler.hpp"
#include "ocppi/runtime/config/types/SchedulerPolicy.hpp"
#include "ocppi/runtime/config/types/SchedulerFlag.hpp"
#include "ocppi/runtime/config/types/Rlimit.hpp"
#include "ocppi/runtime/config/types/IoPriority.hpp"
#include "ocppi/runtime/config/types/Class.hpp"
#include "ocppi/runtime/config/types/ConsoleSize.hpp"
#include "ocppi/runtime/config/types/Capabilities.hpp"
#include "ocppi/runtime/config/types/Mount.hpp"
#include "ocppi/runtime/config/types/Linux.hpp"
#include "ocppi/runtime/config/types/TimeOffsets.hpp"
#include "ocppi/runtime/config/types/BoottimeClass.hpp"
#include "ocppi/runtime/config/types/Seccomp.hpp"
#include "ocppi/runtime/config/types/Syscall.hpp"
#include "ocppi/runtime/config/types/SyscallArg.hpp"
#include "ocppi/runtime/config/types/SeccompOperators.hpp"
#include "ocppi/runtime/config/types/SeccompFlag.hpp"
#include "ocppi/runtime/config/types/SeccompAction.hpp"
#include "ocppi/runtime/config/types/SeccompArch.hpp"
#include "ocppi/runtime/config/types/RootfsPropagation.hpp"
#include "ocppi/runtime/config/types/LinuxResources.hpp"
#include "ocppi/runtime/config/types/Rdma.hpp"
#include "ocppi/runtime/config/types/Pids.hpp"
#include "ocppi/runtime/config/types/ResourcesNetwork.hpp"
#include "ocppi/runtime/config/types/NetworkInterfacePriority.hpp"
#include "ocppi/runtime/config/types/PurpleMemory.hpp"
#include "ocppi/runtime/config/types/HugepageLimit.hpp"
#include "ocppi/runtime/config/types/DeviceCgroup.hpp"
#include "ocppi/runtime/config/types/PurpleCPU.hpp"
#include "ocppi/runtime/config/types/BlockIO.hpp"
#include "ocppi/runtime/config/types/BlockIODeviceWeight.hpp"
#include "ocppi/runtime/config/types/BlockIODeviceThrottle.hpp"
#include "ocppi/runtime/config/types/Personality.hpp"
#include "ocppi/runtime/config/types/PersonalityDomain.hpp"
#include "ocppi/runtime/config/types/NamespaceReference.hpp"
#include "ocppi/runtime/config/types/NamespaceType.hpp"
#include "ocppi/runtime/config/types/IntelRdt.hpp"
#include "ocppi/runtime/config/types/IdMapping.hpp"
#include "ocppi/runtime/config/types/LinuxDevice.hpp"
#include "ocppi/runtime/config/types/Hooks.hpp"
#include "ocppi/runtime/config/types/Hook.hpp"

namespace ocppi {
namespace runtime {
namespace config {
namespace types {
void from_json(const json & j, Hook & x);
void to_json(json & j, const Hook & x);

void from_json(const json & j, Hooks & x);
void to_json(json & j, const Hooks & x);

void from_json(const json & j, LinuxDevice & x);
void to_json(json & j, const LinuxDevice & x);

void from_json(const json & j, IdMapping & x);
void to_json(json & j, const IdMapping & x);

void from_json(const json & j, IntelRdt & x);
void to_json(json & j, const IntelRdt & x);

void from_json(const json & j, NamespaceReference & x);
void to_json(json & j, const NamespaceReference & x);

void from_json(const json & j, Personality & x);
void to_json(json & j, const Personality & x);

void from_json(const json & j, BlockIODeviceThrottle & x);
void to_json(json & j, const BlockIODeviceThrottle & x);

void from_json(const json & j, BlockIODeviceWeight & x);
void to_json(json & j, const BlockIODeviceWeight & x);

void from_json(const json & j, BlockIO & x);
void to_json(json & j, const BlockIO & x);

void from_json(const json & j, PurpleCPU & x);
void to_json(json & j, const PurpleCPU & x);

void from_json(const json & j, DeviceCgroup & x);
void to_json(json & j, const DeviceCgroup & x);

void from_json(const json & j, HugepageLimit & x);
void to_json(json & j, const HugepageLimit & x);

void from_json(const json & j, PurpleMemory & x);
void to_json(json & j, const PurpleMemory & x);

void from_json(const json & j, NetworkInterfacePriority & x);
void to_json(json & j, const NetworkInterfacePriority & x);

void from_json(const json & j, ResourcesNetwork & x);
void to_json(json & j, const ResourcesNetwork & x);

void from_json(const json & j, Pids & x);
void to_json(json & j, const Pids & x);

void from_json(const json & j, Rdma & x);
void to_json(json & j, const Rdma & x);

void from_json(const json & j, LinuxResources & x);
void to_json(json & j, const LinuxResources & x);

void from_json(const json & j, SyscallArg & x);
void to_json(json & j, const SyscallArg & x);

void from_json(const json & j, Syscall & x);
void to_json(json & j, const Syscall & x);

void from_json(const json & j, Seccomp & x);
void to_json(json & j, const Seccomp & x);

void from_json(const json & j, BoottimeClass & x);
void to_json(json & j, const BoottimeClass & x);

void from_json(const json & j, TimeOffsets & x);
void to_json(json & j, const TimeOffsets & x);

void from_json(const json & j, Linux & x);
void to_json(json & j, const Linux & x);

void from_json(const json & j, Mount & x);
void to_json(json & j, const Mount & x);

void from_json(const json & j, Capabilities & x);
void to_json(json & j, const Capabilities & x);

void from_json(const json & j, ConsoleSize & x);
void to_json(json & j, const ConsoleSize & x);

void from_json(const json & j, IoPriority & x);
void to_json(json & j, const IoPriority & x);

void from_json(const json & j, Rlimit & x);
void to_json(json & j, const Rlimit & x);

void from_json(const json & j, Scheduler & x);
void to_json(json & j, const Scheduler & x);

void from_json(const json & j, User & x);
void to_json(json & j, const User & x);

void from_json(const json & j, Process & x);
void to_json(json & j, const Process & x);

void from_json(const json & j, Root & x);
void to_json(json & j, const Root & x);

void from_json(const json & j, Anet & x);
void to_json(json & j, const Anet & x);

void from_json(const json & j, CappedCPU & x);
void to_json(json & j, const CappedCPU & x);

void from_json(const json & j, CappedMemory & x);
void to_json(json & j, const CappedMemory & x);

void from_json(const json & j, Solaris & x);
void to_json(json & j, const Solaris & x);

void from_json(const json & j, Hypervisor & x);
void to_json(json & j, const Hypervisor & x);

void from_json(const json & j, Image & x);
void to_json(json & j, const Image & x);

void from_json(const json & j, Kernel & x);
void to_json(json & j, const Kernel & x);

void from_json(const json & j, Vm & x);
void to_json(json & j, const Vm & x);

void from_json(const json & j, WindowsDevice & x);
void to_json(json & j, const WindowsDevice & x);

void from_json(const json & j, Hyperv & x);
void to_json(json & j, const Hyperv & x);

void from_json(const json & j, WindowsNetwork & x);
void to_json(json & j, const WindowsNetwork & x);

void from_json(const json & j, FluffyCPU & x);
void to_json(json & j, const FluffyCPU & x);

void from_json(const json & j, FluffyMemory & x);
void to_json(json & j, const FluffyMemory & x);

void from_json(const json & j, Storage & x);
void to_json(json & j, const Storage & x);

void from_json(const json & j, WindowsResources & x);
void to_json(json & j, const WindowsResources & x);

void from_json(const json & j, Windows & x);
void to_json(json & j, const Windows & x);

void from_json(const json & j, ZosDevice & x);
void to_json(json & j, const ZosDevice & x);

void from_json(const json & j, Zos & x);
void to_json(json & j, const Zos & x);

void from_json(const json & j, Config & x);
void to_json(json & j, const Config & x);

void from_json(const json & j, NamespaceType & x);
void to_json(json & j, const NamespaceType & x);

void from_json(const json & j, PersonalityDomain & x);
void to_json(json & j, const PersonalityDomain & x);

void from_json(const json & j, RootfsPropagation & x);
void to_json(json & j, const RootfsPropagation & x);

void from_json(const json & j, SeccompArch & x);
void to_json(json & j, const SeccompArch & x);

void from_json(const json & j, SeccompAction & x);
void to_json(json & j, const SeccompAction & x);

void from_json(const json & j, SeccompFlag & x);
void to_json(json & j, const SeccompFlag & x);

void from_json(const json & j, SeccompOperators & x);
void to_json(json & j, const SeccompOperators & x);

void from_json(const json & j, Class & x);
void to_json(json & j, const Class & x);

void from_json(const json & j, SchedulerFlag & x);
void to_json(json & j, const SchedulerFlag & x);

void from_json(const json & j, SchedulerPolicy & x);
void to_json(json & j, const SchedulerPolicy & x);

void from_json(const json & j, RootImageFormat & x);
void to_json(json & j, const RootImageFormat & x);

void from_json(const json & j, IdType & x);
void to_json(json & j, const IdType & x);

inline void from_json(const json & j, Hook& x) {
x.args = get_stack_optional<std::vector<std::string>>(j, "args");
x.env = get_stack_optional<std::vector<std::string>>(j, "env");
x.path = j.at("path").get<std::string>();
x.timeout = get_stack_optional<int64_t>(j, "timeout");
}

inline void to_json(json & j, const Hook & x) {
j = json::object();
if (x.args) {
j["args"] = x.args;
}
if (x.env) {
j["env"] = x.env;
}
j["path"] = x.path;
if (x.timeout) {
j["timeout"] = x.timeout;
}
}

inline void from_json(const json & j, Hooks& x) {
x.createContainer = get_stack_optional<std::vector<Hook>>(j, "createContainer");
x.createRuntime = get_stack_optional<std::vector<Hook>>(j, "createRuntime");
x.poststart = get_stack_optional<std::vector<Hook>>(j, "poststart");
x.poststop = get_stack_optional<std::vector<Hook>>(j, "poststop");
x.prestart = get_stack_optional<std::vector<Hook>>(j, "prestart");
x.startContainer = get_stack_optional<std::vector<Hook>>(j, "startContainer");
}

inline void to_json(json & j, const Hooks & x) {
j = json::object();
if (x.createContainer) {
j["createContainer"] = x.createContainer;
}
if (x.createRuntime) {
j["createRuntime"] = x.createRuntime;
}
if (x.poststart) {
j["poststart"] = x.poststart;
}
if (x.poststop) {
j["poststop"] = x.poststop;
}
if (x.prestart) {
j["prestart"] = x.prestart;
}
if (x.startContainer) {
j["startContainer"] = x.startContainer;
}
}

inline void from_json(const json & j, LinuxDevice& x) {
x.fileMode = get_stack_optional<int64_t>(j, "fileMode");
x.gid = get_stack_optional<int64_t>(j, "gid");
x.major = get_stack_optional<int64_t>(j, "major");
x.minor = get_stack_optional<int64_t>(j, "minor");
x.path = j.at("path").get<std::string>();
x.type = j.at("type").get<std::string>();
x.uid = get_stack_optional<int64_t>(j, "uid");
}

inline void to_json(json & j, const LinuxDevice & x) {
j = json::object();
if (x.fileMode) {
j["fileMode"] = x.fileMode;
}
if (x.gid) {
j["gid"] = x.gid;
}
if (x.major) {
j["major"] = x.major;
}
if (x.minor) {
j["minor"] = x.minor;
}
j["path"] = x.path;
j["type"] = x.type;
if (x.uid) {
j["uid"] = x.uid;
}
}

inline void from_json(const json & j, IdMapping& x) {
x.containerID = j.at("containerID").get<int64_t>();
x.hostID = j.at("hostID").get<int64_t>();
x.size = j.at("size").get<int64_t>();
}

inline void to_json(json & j, const IdMapping & x) {
j = json::object();
j["containerID"] = x.containerID;
j["hostID"] = x.hostID;
j["size"] = x.size;
}

inline void from_json(const json & j, IntelRdt& x) {
x.closID = get_stack_optional<std::string>(j, "closID");
x.enableCMT = get_stack_optional<bool>(j, "enableCMT");
x.enableMBM = get_stack_optional<bool>(j, "enableMBM");
x.l3CacheSchema = get_stack_optional<std::string>(j, "l3CacheSchema");
x.memBWSchema = get_stack_optional<std::string>(j, "memBwSchema");
}

inline void to_json(json & j, const IntelRdt & x) {
j = json::object();
if (x.closID) {
j["closID"] = x.closID;
}
if (x.enableCMT) {
j["enableCMT"] = x.enableCMT;
}
if (x.enableMBM) {
j["enableMBM"] = x.enableMBM;
}
if (x.l3CacheSchema) {
j["l3CacheSchema"] = x.l3CacheSchema;
}
if (x.memBWSchema) {
j["memBwSchema"] = x.memBWSchema;
}
}

inline void from_json(const json & j, NamespaceReference& x) {
x.path = get_stack_optional<std::string>(j, "path");
x.type = j.at("type").get<NamespaceType>();
}

inline void to_json(json & j, const NamespaceReference & x) {
j = json::object();
if (x.path) {
j["path"] = x.path;
}
j["type"] = x.type;
}

inline void from_json(const json & j, Personality& x) {
x.domain = get_stack_optional<PersonalityDomain>(j, "domain");
x.flags = get_stack_optional<std::vector<std::string>>(j, "flags");
}

inline void to_json(json & j, const Personality & x) {
j = json::object();
if (x.domain) {
j["domain"] = x.domain;
}
if (x.flags) {
j["flags"] = x.flags;
}
}

inline void from_json(const json & j, BlockIODeviceThrottle& x) {
x.major = j.at("major").get<int64_t>();
x.minor = j.at("minor").get<int64_t>();
x.rate = get_stack_optional<int64_t>(j, "rate");
}

inline void to_json(json & j, const BlockIODeviceThrottle & x) {
j = json::object();
j["major"] = x.major;
j["minor"] = x.minor;
if (x.rate) {
j["rate"] = x.rate;
}
}

inline void from_json(const json & j, BlockIODeviceWeight& x) {
x.major = j.at("major").get<int64_t>();
x.minor = j.at("minor").get<int64_t>();
x.leafWeight = get_stack_optional<int64_t>(j, "leafWeight");
x.weight = get_stack_optional<int64_t>(j, "weight");
}

inline void to_json(json & j, const BlockIODeviceWeight & x) {
j = json::object();
j["major"] = x.major;
j["minor"] = x.minor;
if (x.leafWeight) {
j["leafWeight"] = x.leafWeight;
}
if (x.weight) {
j["weight"] = x.weight;
}
}

inline void from_json(const json & j, BlockIO& x) {
x.leafWeight = get_stack_optional<int64_t>(j, "leafWeight");
x.throttleReadBpsDevice = get_stack_optional<std::vector<BlockIODeviceThrottle>>(j, "throttleReadBpsDevice");
x.throttleReadIOPSDevice = get_stack_optional<std::vector<BlockIODeviceThrottle>>(j, "throttleReadIOPSDevice");
x.throttleWriteBpsDevice = get_stack_optional<std::vector<BlockIODeviceThrottle>>(j, "throttleWriteBpsDevice");
x.throttleWriteIOPSDevice = get_stack_optional<std::vector<BlockIODeviceThrottle>>(j, "throttleWriteIOPSDevice");
x.weight = get_stack_optional<int64_t>(j, "weight");
x.weightDevice = get_stack_optional<std::vector<BlockIODeviceWeight>>(j, "weightDevice");
}

inline void to_json(json & j, const BlockIO & x) {
j = json::object();
if (x.leafWeight) {
j["leafWeight"] = x.leafWeight;
}
if (x.throttleReadBpsDevice) {
j["throttleReadBpsDevice"] = x.throttleReadBpsDevice;
}
if (x.throttleReadIOPSDevice) {
j["throttleReadIOPSDevice"] = x.throttleReadIOPSDevice;
}
if (x.throttleWriteBpsDevice) {
j["throttleWriteBpsDevice"] = x.throttleWriteBpsDevice;
}
if (x.throttleWriteIOPSDevice) {
j["throttleWriteIOPSDevice"] = x.throttleWriteIOPSDevice;
}
if (x.weight) {
j["weight"] = x.weight;
}
if (x.weightDevice) {
j["weightDevice"] = x.weightDevice;
}
}

inline void from_json(const json & j, PurpleCPU& x) {
x.burst = get_stack_optional<int64_t>(j, "burst");
x.cpus = get_stack_optional<std::string>(j, "cpus");
x.idle = get_stack_optional<int64_t>(j, "idle");
x.mems = get_stack_optional<std::string>(j, "mems");
x.period = get_stack_optional<int64_t>(j, "period");
x.quota = get_stack_optional<int64_t>(j, "quota");
x.realtimePeriod = get_stack_optional<int64_t>(j, "realtimePeriod");
x.realtimeRuntime = get_stack_optional<int64_t>(j, "realtimeRuntime");
x.shares = get_stack_optional<int64_t>(j, "shares");
}

inline void to_json(json & j, const PurpleCPU & x) {
j = json::object();
if (x.burst) {
j["burst"] = x.burst;
}
if (x.cpus) {
j["cpus"] = x.cpus;
}
if (x.idle) {
j["idle"] = x.idle;
}
if (x.mems) {
j["mems"] = x.mems;
}
if (x.period) {
j["period"] = x.period;
}
if (x.quota) {
j["quota"] = x.quota;
}
if (x.realtimePeriod) {
j["realtimePeriod"] = x.realtimePeriod;
}
if (x.realtimeRuntime) {
j["realtimeRuntime"] = x.realtimeRuntime;
}
if (x.shares) {
j["shares"] = x.shares;
}
}

inline void from_json(const json & j, DeviceCgroup& x) {
x.access = get_stack_optional<std::string>(j, "access");
x.allow = j.at("allow").get<bool>();
x.major = get_stack_optional<int64_t>(j, "major");
x.minor = get_stack_optional<int64_t>(j, "minor");
x.type = get_stack_optional<std::string>(j, "type");
}

inline void to_json(json & j, const DeviceCgroup & x) {
j = json::object();
if (x.access) {
j["access"] = x.access;
}
j["allow"] = x.allow;
if (x.major) {
j["major"] = x.major;
}
if (x.minor) {
j["minor"] = x.minor;
}
if (x.type) {
j["type"] = x.type;
}
}

inline void from_json(const json & j, HugepageLimit& x) {
x.limit = j.at("limit").get<int64_t>();
x.pageSize = j.at("pageSize").get<std::string>();
}

inline void to_json(json & j, const HugepageLimit & x) {
j = json::object();
j["limit"] = x.limit;
j["pageSize"] = x.pageSize;
}

inline void from_json(const json & j, PurpleMemory& x) {
x.checkBeforeUpdate = get_stack_optional<bool>(j, "checkBeforeUpdate");
x.disableOOMKiller = get_stack_optional<bool>(j, "disableOOMKiller");
x.kernel = get_stack_optional<int64_t>(j, "kernel");
x.kernelTCP = get_stack_optional<int64_t>(j, "kernelTCP");
x.limit = get_stack_optional<int64_t>(j, "limit");
x.reservation = get_stack_optional<int64_t>(j, "reservation");
x.swap = get_stack_optional<int64_t>(j, "swap");
x.swappiness = get_stack_optional<int64_t>(j, "swappiness");
x.useHierarchy = get_stack_optional<bool>(j, "useHierarchy");
}

inline void to_json(json & j, const PurpleMemory & x) {
j = json::object();
if (x.checkBeforeUpdate) {
j["checkBeforeUpdate"] = x.checkBeforeUpdate;
}
if (x.disableOOMKiller) {
j["disableOOMKiller"] = x.disableOOMKiller;
}
if (x.kernel) {
j["kernel"] = x.kernel;
}
if (x.kernelTCP) {
j["kernelTCP"] = x.kernelTCP;
}
if (x.limit) {
j["limit"] = x.limit;
}
if (x.reservation) {
j["reservation"] = x.reservation;
}
if (x.swap) {
j["swap"] = x.swap;
}
if (x.swappiness) {
j["swappiness"] = x.swappiness;
}
if (x.useHierarchy) {
j["useHierarchy"] = x.useHierarchy;
}
}

inline void from_json(const json & j, NetworkInterfacePriority& x) {
x.name = j.at("name").get<std::string>();
x.priority = j.at("priority").get<int64_t>();
}

inline void to_json(json & j, const NetworkInterfacePriority & x) {
j = json::object();
j["name"] = x.name;
j["priority"] = x.priority;
}

inline void from_json(const json & j, ResourcesNetwork& x) {
x.classID = get_stack_optional<int64_t>(j, "classID");
x.priorities = get_stack_optional<std::vector<NetworkInterfacePriority>>(j, "priorities");
}

inline void to_json(json & j, const ResourcesNetwork & x) {
j = json::object();
if (x.classID) {
j["classID"] = x.classID;
}
if (x.priorities) {
j["priorities"] = x.priorities;
}
}

inline void from_json(const json & j, Pids& x) {
x.limit = j.at("limit").get<int64_t>();
}

inline void to_json(json & j, const Pids & x) {
j = json::object();
j["limit"] = x.limit;
}

inline void from_json(const json & j, Rdma& x) {
x.hcaHandles = get_stack_optional<int64_t>(j, "hcaHandles");
x.hcaObjects = get_stack_optional<int64_t>(j, "hcaObjects");
}

inline void to_json(json & j, const Rdma & x) {
j = json::object();
if (x.hcaHandles) {
j["hcaHandles"] = x.hcaHandles;
}
if (x.hcaObjects) {
j["hcaObjects"] = x.hcaObjects;
}
}

inline void from_json(const json & j, LinuxResources& x) {
x.blockIO = get_stack_optional<BlockIO>(j, "blockIO");
x.cpu = get_stack_optional<PurpleCPU>(j, "cpu");
x.devices = get_stack_optional<std::vector<DeviceCgroup>>(j, "devices");
x.hugepageLimits = get_stack_optional<std::vector<HugepageLimit>>(j, "hugepageLimits");
x.memory = get_stack_optional<PurpleMemory>(j, "memory");
x.network = get_stack_optional<ResourcesNetwork>(j, "network");
x.pids = get_stack_optional<Pids>(j, "pids");
x.rdma = get_stack_optional<std::map<std::string, Rdma>>(j, "rdma");
x.unified = get_stack_optional<std::map<std::string, std::string>>(j, "unified");
}

inline void to_json(json & j, const LinuxResources & x) {
j = json::object();
if (x.blockIO) {
j["blockIO"] = x.blockIO;
}
if (x.cpu) {
j["cpu"] = x.cpu;
}
if (x.devices) {
j["devices"] = x.devices;
}
if (x.hugepageLimits) {
j["hugepageLimits"] = x.hugepageLimits;
}
if (x.memory) {
j["memory"] = x.memory;
}
if (x.network) {
j["network"] = x.network;
}
if (x.pids) {
j["pids"] = x.pids;
}
if (x.rdma) {
j["rdma"] = x.rdma;
}
if (x.unified) {
j["unified"] = x.unified;
}
}

inline void from_json(const json & j, SyscallArg& x) {
x.index = j.at("index").get<int64_t>();
x.op = j.at("op").get<SeccompOperators>();
x.value = j.at("value").get<int64_t>();
x.valueTwo = get_stack_optional<int64_t>(j, "valueTwo");
}

inline void to_json(json & j, const SyscallArg & x) {
j = json::object();
j["index"] = x.index;
j["op"] = x.op;
j["value"] = x.value;
if (x.valueTwo) {
j["valueTwo"] = x.valueTwo;
}
}

inline void from_json(const json & j, Syscall& x) {
x.action = j.at("action").get<SeccompAction>();
x.args = get_stack_optional<std::vector<SyscallArg>>(j, "args");
x.errnoRet = get_stack_optional<int64_t>(j, "errnoRet");
x.names = j.at("names").get<std::vector<std::string>>();
}

inline void to_json(json & j, const Syscall & x) {
j = json::object();
j["action"] = x.action;
if (x.args) {
j["args"] = x.args;
}
if (x.errnoRet) {
j["errnoRet"] = x.errnoRet;
}
j["names"] = x.names;
}

inline void from_json(const json & j, Seccomp& x) {
x.architectures = get_stack_optional<std::vector<SeccompArch>>(j, "architectures");
x.defaultAction = j.at("defaultAction").get<SeccompAction>();
x.defaultErrnoRet = get_stack_optional<int64_t>(j, "defaultErrnoRet");
x.flags = get_stack_optional<std::vector<SeccompFlag>>(j, "flags");
x.listenerMetadata = get_stack_optional<std::string>(j, "listenerMetadata");
x.listenerPath = get_stack_optional<std::string>(j, "listenerPath");
x.syscalls = get_stack_optional<std::vector<Syscall>>(j, "syscalls");
}

inline void to_json(json & j, const Seccomp & x) {
j = json::object();
if (x.architectures) {
j["architectures"] = x.architectures;
}
j["defaultAction"] = x.defaultAction;
if (x.defaultErrnoRet) {
j["defaultErrnoRet"] = x.defaultErrnoRet;
}
if (x.flags) {
j["flags"] = x.flags;
}
if (x.listenerMetadata) {
j["listenerMetadata"] = x.listenerMetadata;
}
if (x.listenerPath) {
j["listenerPath"] = x.listenerPath;
}
if (x.syscalls) {
j["syscalls"] = x.syscalls;
}
}

inline void from_json(const json & j, BoottimeClass& x) {
x.nanosecs = get_stack_optional<int64_t>(j, "nanosecs");
x.secs = get_stack_optional<int64_t>(j, "secs");
}

inline void to_json(json & j, const BoottimeClass & x) {
j = json::object();
if (x.nanosecs) {
j["nanosecs"] = x.nanosecs;
}
if (x.secs) {
j["secs"] = x.secs;
}
}

inline void from_json(const json & j, TimeOffsets& x) {
x.boottime = get_stack_optional<BoottimeClass>(j, "boottime");
x.monotonic = get_stack_optional<BoottimeClass>(j, "monotonic");
}

inline void to_json(json & j, const TimeOffsets & x) {
j = json::object();
if (x.boottime) {
j["boottime"] = x.boottime;
}
if (x.monotonic) {
j["monotonic"] = x.monotonic;
}
}

inline void from_json(const json & j, Linux& x) {
x.cgroupsPath = get_stack_optional<std::string>(j, "cgroupsPath");
x.devices = get_stack_optional<std::vector<LinuxDevice>>(j, "devices");
x.gidMappings = get_stack_optional<std::vector<IdMapping>>(j, "gidMappings");
x.intelRdt = get_stack_optional<IntelRdt>(j, "intelRdt");
x.maskedPaths = get_stack_optional<std::vector<std::string>>(j, "maskedPaths");
x.mountLabel = get_stack_optional<std::string>(j, "mountLabel");
x.namespaces = get_stack_optional<std::vector<NamespaceReference>>(j, "namespaces");
x.personality = get_stack_optional<Personality>(j, "personality");
x.readonlyPaths = get_stack_optional<std::vector<std::string>>(j, "readonlyPaths");
x.resources = get_stack_optional<LinuxResources>(j, "resources");
x.rootfsPropagation = get_stack_optional<RootfsPropagation>(j, "rootfsPropagation");
x.seccomp = get_stack_optional<Seccomp>(j, "seccomp");
x.sysctl = get_stack_optional<std::map<std::string, std::string>>(j, "sysctl");
x.timeOffsets = get_stack_optional<TimeOffsets>(j, "timeOffsets");
x.uidMappings = get_stack_optional<std::vector<IdMapping>>(j, "uidMappings");
}

inline void to_json(json & j, const Linux & x) {
j = json::object();
if (x.cgroupsPath) {
j["cgroupsPath"] = x.cgroupsPath;
}
if (x.devices) {
j["devices"] = x.devices;
}
if (x.gidMappings) {
j["gidMappings"] = x.gidMappings;
}
if (x.intelRdt) {
j["intelRdt"] = x.intelRdt;
}
if (x.maskedPaths) {
j["maskedPaths"] = x.maskedPaths;
}
if (x.mountLabel) {
j["mountLabel"] = x.mountLabel;
}
if (x.namespaces) {
j["namespaces"] = x.namespaces;
}
if (x.personality) {
j["personality"] = x.personality;
}
if (x.readonlyPaths) {
j["readonlyPaths"] = x.readonlyPaths;
}
if (x.resources) {
j["resources"] = x.resources;
}
if (x.rootfsPropagation) {
j["rootfsPropagation"] = x.rootfsPropagation;
}
if (x.seccomp) {
j["seccomp"] = x.seccomp;
}
if (x.sysctl) {
j["sysctl"] = x.sysctl;
}
if (x.timeOffsets) {
j["timeOffsets"] = x.timeOffsets;
}
if (x.uidMappings) {
j["uidMappings"] = x.uidMappings;
}
}

inline void from_json(const json & j, Mount& x) {
x.destination = j.at("destination").get<std::string>();
x.gidMappings = get_stack_optional<std::vector<IdMapping>>(j, "gidMappings");
x.options = get_stack_optional<std::vector<std::string>>(j, "options");
x.source = get_stack_optional<std::string>(j, "source");
x.type = get_stack_optional<std::string>(j, "type");
x.uidMappings = get_stack_optional<std::vector<IdMapping>>(j, "uidMappings");
}

inline void to_json(json & j, const Mount & x) {
j = json::object();
j["destination"] = x.destination;
if (x.gidMappings) {
j["gidMappings"] = x.gidMappings;
}
if (x.options) {
j["options"] = x.options;
}
if (x.source) {
j["source"] = x.source;
}
if (x.type) {
j["type"] = x.type;
}
if (x.uidMappings) {
j["uidMappings"] = x.uidMappings;
}
}

inline void from_json(const json & j, Capabilities& x) {
x.ambient = get_stack_optional<std::vector<std::string>>(j, "ambient");
x.bounding = get_stack_optional<std::vector<std::string>>(j, "bounding");
x.effective = get_stack_optional<std::vector<std::string>>(j, "effective");
x.inheritable = get_stack_optional<std::vector<std::string>>(j, "inheritable");
x.permitted = get_stack_optional<std::vector<std::string>>(j, "permitted");
}

inline void to_json(json & j, const Capabilities & x) {
j = json::object();
if (x.ambient) {
j["ambient"] = x.ambient;
}
if (x.bounding) {
j["bounding"] = x.bounding;
}
if (x.effective) {
j["effective"] = x.effective;
}
if (x.inheritable) {
j["inheritable"] = x.inheritable;
}
if (x.permitted) {
j["permitted"] = x.permitted;
}
}

inline void from_json(const json & j, ConsoleSize& x) {
x.height = j.at("height").get<int64_t>();
x.width = j.at("width").get<int64_t>();
}

inline void to_json(json & j, const ConsoleSize & x) {
j = json::object();
j["height"] = x.height;
j["width"] = x.width;
}

inline void from_json(const json & j, IoPriority& x) {
x.ioPriorityClass = j.at("class").get<Class>();
x.priority = get_stack_optional<int64_t>(j, "priority");
}

inline void to_json(json & j, const IoPriority & x) {
j = json::object();
j["class"] = x.ioPriorityClass;
if (x.priority) {
j["priority"] = x.priority;
}
}

inline void from_json(const json & j, Rlimit& x) {
x.hard = j.at("hard").get<int64_t>();
x.soft = j.at("soft").get<int64_t>();
x.type = j.at("type").get<std::string>();
}

inline void to_json(json & j, const Rlimit & x) {
j = json::object();
j["hard"] = x.hard;
j["soft"] = x.soft;
j["type"] = x.type;
}

inline void from_json(const json & j, Scheduler& x) {
x.deadline = get_stack_optional<int64_t>(j, "deadline");
x.flags = get_stack_optional<std::vector<SchedulerFlag>>(j, "flags");
x.nice = get_stack_optional<int64_t>(j, "nice");
x.period = get_stack_optional<int64_t>(j, "period");
x.policy = j.at("policy").get<SchedulerPolicy>();
x.priority = get_stack_optional<int64_t>(j, "priority");
x.runtime = get_stack_optional<int64_t>(j, "runtime");
}

inline void to_json(json & j, const Scheduler & x) {
j = json::object();
if (x.deadline) {
j["deadline"] = x.deadline;
}
if (x.flags) {
j["flags"] = x.flags;
}
if (x.nice) {
j["nice"] = x.nice;
}
if (x.period) {
j["period"] = x.period;
}
j["policy"] = x.policy;
if (x.priority) {
j["priority"] = x.priority;
}
if (x.runtime) {
j["runtime"] = x.runtime;
}
}

inline void from_json(const json & j, User& x) {
x.additionalGids = get_stack_optional<std::vector<int64_t>>(j, "additionalGids");
x.gid = get_stack_optional<int64_t>(j, "gid");
x.uid = get_stack_optional<int64_t>(j, "uid");
x.umask = get_stack_optional<int64_t>(j, "umask");
x.username = get_stack_optional<std::string>(j, "username");
}

inline void to_json(json & j, const User & x) {
j = json::object();
if (x.additionalGids) {
j["additionalGids"] = x.additionalGids;
}
if (x.gid) {
j["gid"] = x.gid;
}
if (x.uid) {
j["uid"] = x.uid;
}
if (x.umask) {
j["umask"] = x.umask;
}
if (x.username) {
j["username"] = x.username;
}
}

inline void from_json(const json & j, Process& x) {
x.apparmorProfile = get_stack_optional<std::string>(j, "apparmorProfile");
x.args = get_stack_optional<std::vector<std::string>>(j, "args");
x.capabilities = get_stack_optional<Capabilities>(j, "capabilities");
x.commandLine = get_stack_optional<std::string>(j, "commandLine");
x.consoleSize = get_stack_optional<ConsoleSize>(j, "consoleSize");
x.cwd = j.at("cwd").get<std::string>();
x.env = get_stack_optional<std::vector<std::string>>(j, "env");
x.ioPriority = get_stack_optional<IoPriority>(j, "ioPriority");
x.noNewPrivileges = get_stack_optional<bool>(j, "noNewPrivileges");
x.oomScoreAdj = get_stack_optional<int64_t>(j, "oomScoreAdj");
x.rlimits = get_stack_optional<std::vector<Rlimit>>(j, "rlimits");
x.scheduler = get_stack_optional<Scheduler>(j, "scheduler");
x.selinuxLabel = get_stack_optional<std::string>(j, "selinuxLabel");
x.terminal = get_stack_optional<bool>(j, "terminal");
x.user = get_stack_optional<User>(j, "user");
}

inline void to_json(json & j, const Process & x) {
j = json::object();
if (x.apparmorProfile) {
j["apparmorProfile"] = x.apparmorProfile;
}
if (x.args) {
j["args"] = x.args;
}
if (x.capabilities) {
j["capabilities"] = x.capabilities;
}
if (x.commandLine) {
j["commandLine"] = x.commandLine;
}
if (x.consoleSize) {
j["consoleSize"] = x.consoleSize;
}
j["cwd"] = x.cwd;
if (x.env) {
j["env"] = x.env;
}
if (x.ioPriority) {
j["ioPriority"] = x.ioPriority;
}
if (x.noNewPrivileges) {
j["noNewPrivileges"] = x.noNewPrivileges;
}
if (x.oomScoreAdj) {
j["oomScoreAdj"] = x.oomScoreAdj;
}
if (x.rlimits) {
j["rlimits"] = x.rlimits;
}
if (x.scheduler) {
j["scheduler"] = x.scheduler;
}
if (x.selinuxLabel) {
j["selinuxLabel"] = x.selinuxLabel;
}
if (x.terminal) {
j["terminal"] = x.terminal;
}
if (x.user) {
j["user"] = x.user;
}
}

inline void from_json(const json & j, Root& x) {
x.path = j.at("path").get<std::string>();
x.readonly = get_stack_optional<bool>(j, "readonly");
}

inline void to_json(json & j, const Root & x) {
j = json::object();
j["path"] = x.path;
if (x.readonly) {
j["readonly"] = x.readonly;
}
}

inline void from_json(const json & j, Anet& x) {
x.allowedAddress = get_stack_optional<std::string>(j, "allowedAddress");
x.configureAllowedAddress = get_stack_optional<std::string>(j, "configureAllowedAddress");
x.defrouter = get_stack_optional<std::string>(j, "defrouter");
x.linkname = get_stack_optional<std::string>(j, "linkname");
x.linkProtection = get_stack_optional<std::string>(j, "linkProtection");
x.lowerLink = get_stack_optional<std::string>(j, "lowerLink");
x.macAddress = get_stack_optional<std::string>(j, "macAddress");
}

inline void to_json(json & j, const Anet & x) {
j = json::object();
if (x.allowedAddress) {
j["allowedAddress"] = x.allowedAddress;
}
if (x.configureAllowedAddress) {
j["configureAllowedAddress"] = x.configureAllowedAddress;
}
if (x.defrouter) {
j["defrouter"] = x.defrouter;
}
if (x.linkname) {
j["linkname"] = x.linkname;
}
if (x.linkProtection) {
j["linkProtection"] = x.linkProtection;
}
if (x.lowerLink) {
j["lowerLink"] = x.lowerLink;
}
if (x.macAddress) {
j["macAddress"] = x.macAddress;
}
}

inline void from_json(const json & j, CappedCPU& x) {
x.ncpus = get_stack_optional<std::string>(j, "ncpus");
}

inline void to_json(json & j, const CappedCPU & x) {
j = json::object();
if (x.ncpus) {
j["ncpus"] = x.ncpus;
}
}

inline void from_json(const json & j, CappedMemory& x) {
x.physical = get_stack_optional<std::string>(j, "physical");
x.swap = get_stack_optional<std::string>(j, "swap");
}

inline void to_json(json & j, const CappedMemory & x) {
j = json::object();
if (x.physical) {
j["physical"] = x.physical;
}
if (x.swap) {
j["swap"] = x.swap;
}
}

inline void from_json(const json & j, Solaris& x) {
x.anet = get_stack_optional<std::vector<Anet>>(j, "anet");
x.cappedCPU = get_stack_optional<CappedCPU>(j, "cappedCPU");
x.cappedMemory = get_stack_optional<CappedMemory>(j, "cappedMemory");
x.limitpriv = get_stack_optional<std::string>(j, "limitpriv");
x.maxShmMemory = get_stack_optional<std::string>(j, "maxShmMemory");
x.milestone = get_stack_optional<std::string>(j, "milestone");
}

inline void to_json(json & j, const Solaris & x) {
j = json::object();
if (x.anet) {
j["anet"] = x.anet;
}
if (x.cappedCPU) {
j["cappedCPU"] = x.cappedCPU;
}
if (x.cappedMemory) {
j["cappedMemory"] = x.cappedMemory;
}
if (x.limitpriv) {
j["limitpriv"] = x.limitpriv;
}
if (x.maxShmMemory) {
j["maxShmMemory"] = x.maxShmMemory;
}
if (x.milestone) {
j["milestone"] = x.milestone;
}
}

inline void from_json(const json & j, Hypervisor& x) {
x.parameters = get_stack_optional<std::vector<std::string>>(j, "parameters");
x.path = j.at("path").get<std::string>();
}

inline void to_json(json & j, const Hypervisor & x) {
j = json::object();
if (x.parameters) {
j["parameters"] = x.parameters;
}
j["path"] = x.path;
}

inline void from_json(const json & j, Image& x) {
x.format = j.at("format").get<RootImageFormat>();
x.path = j.at("path").get<std::string>();
}

inline void to_json(json & j, const Image & x) {
j = json::object();
j["format"] = x.format;
j["path"] = x.path;
}

inline void from_json(const json & j, Kernel& x) {
x.initrd = get_stack_optional<std::string>(j, "initrd");
x.parameters = get_stack_optional<std::vector<std::string>>(j, "parameters");
x.path = j.at("path").get<std::string>();
}

inline void to_json(json & j, const Kernel & x) {
j = json::object();
if (x.initrd) {
j["initrd"] = x.initrd;
}
if (x.parameters) {
j["parameters"] = x.parameters;
}
j["path"] = x.path;
}

inline void from_json(const json & j, Vm& x) {
x.hypervisor = get_stack_optional<Hypervisor>(j, "hypervisor");
x.image = get_stack_optional<Image>(j, "image");
x.kernel = j.at("kernel").get<Kernel>();
}

inline void to_json(json & j, const Vm & x) {
j = json::object();
if (x.hypervisor) {
j["hypervisor"] = x.hypervisor;
}
if (x.image) {
j["image"] = x.image;
}
j["kernel"] = x.kernel;
}

inline void from_json(const json & j, WindowsDevice& x) {
x.id = j.at("id").get<std::string>();
x.idType = j.at("idType").get<IdType>();
}

inline void to_json(json & j, const WindowsDevice & x) {
j = json::object();
j["id"] = x.id;
j["idType"] = x.idType;
}

inline void from_json(const json & j, Hyperv& x) {
x.utilityVMPath = get_stack_optional<std::string>(j, "utilityVMPath");
}

inline void to_json(json & j, const Hyperv & x) {
j = json::object();
if (x.utilityVMPath) {
j["utilityVMPath"] = x.utilityVMPath;
}
}

inline void from_json(const json & j, WindowsNetwork& x) {
x.allowUnqualifiedDNSQuery = get_stack_optional<bool>(j, "allowUnqualifiedDNSQuery");
x.dnsSearchList = get_stack_optional<std::vector<std::string>>(j, "DNSSearchList");
x.endpointList = get_stack_optional<std::vector<std::string>>(j, "endpointList");
x.networkNamespace = get_stack_optional<std::string>(j, "networkNamespace");
x.networkSharedContainerName = get_stack_optional<std::string>(j, "networkSharedContainerName");
}

inline void to_json(json & j, const WindowsNetwork & x) {
j = json::object();
if (x.allowUnqualifiedDNSQuery) {
j["allowUnqualifiedDNSQuery"] = x.allowUnqualifiedDNSQuery;
}
if (x.dnsSearchList) {
j["DNSSearchList"] = x.dnsSearchList;
}
if (x.endpointList) {
j["endpointList"] = x.endpointList;
}
if (x.networkNamespace) {
j["networkNamespace"] = x.networkNamespace;
}
if (x.networkSharedContainerName) {
j["networkSharedContainerName"] = x.networkSharedContainerName;
}
}

inline void from_json(const json & j, FluffyCPU& x) {
x.count = get_stack_optional<int64_t>(j, "count");
x.maximum = get_stack_optional<int64_t>(j, "maximum");
x.shares = get_stack_optional<int64_t>(j, "shares");
}

inline void to_json(json & j, const FluffyCPU & x) {
j = json::object();
if (x.count) {
j["count"] = x.count;
}
if (x.maximum) {
j["maximum"] = x.maximum;
}
if (x.shares) {
j["shares"] = x.shares;
}
}

inline void from_json(const json & j, FluffyMemory& x) {
x.limit = get_stack_optional<int64_t>(j, "limit");
}

inline void to_json(json & j, const FluffyMemory & x) {
j = json::object();
if (x.limit) {
j["limit"] = x.limit;
}
}

inline void from_json(const json & j, Storage& x) {
x.bps = get_stack_optional<int64_t>(j, "bps");
x.iops = get_stack_optional<int64_t>(j, "iops");
x.sandboxSize = get_stack_optional<int64_t>(j, "sandboxSize");
}

inline void to_json(json & j, const Storage & x) {
j = json::object();
if (x.bps) {
j["bps"] = x.bps;
}
if (x.iops) {
j["iops"] = x.iops;
}
if (x.sandboxSize) {
j["sandboxSize"] = x.sandboxSize;
}
}

inline void from_json(const json & j, WindowsResources& x) {
x.cpu = get_stack_optional<FluffyCPU>(j, "cpu");
x.memory = get_stack_optional<FluffyMemory>(j, "memory");
x.storage = get_stack_optional<Storage>(j, "storage");
}

inline void to_json(json & j, const WindowsResources & x) {
j = json::object();
if (x.cpu) {
j["cpu"] = x.cpu;
}
if (x.memory) {
j["memory"] = x.memory;
}
if (x.storage) {
j["storage"] = x.storage;
}
}

inline void from_json(const json & j, Windows& x) {
x.credentialSpec = get_stack_optional<std::map<std::string, nlohmann::json>>(j, "credentialSpec");
x.devices = get_stack_optional<std::vector<WindowsDevice>>(j, "devices");
x.hyperv = get_stack_optional<Hyperv>(j, "hyperv");
x.ignoreFlushesDuringBoot = get_stack_optional<bool>(j, "ignoreFlushesDuringBoot");
x.layerFolders = j.at("layerFolders").get<std::vector<std::string>>();
x.network = get_stack_optional<WindowsNetwork>(j, "network");
x.resources = get_stack_optional<WindowsResources>(j, "resources");
x.servicing = get_stack_optional<bool>(j, "servicing");
}

inline void to_json(json & j, const Windows & x) {
j = json::object();
if (x.credentialSpec) {
j["credentialSpec"] = x.credentialSpec;
}
if (x.devices) {
j["devices"] = x.devices;
}
if (x.hyperv) {
j["hyperv"] = x.hyperv;
}
if (x.ignoreFlushesDuringBoot) {
j["ignoreFlushesDuringBoot"] = x.ignoreFlushesDuringBoot;
}
j["layerFolders"] = x.layerFolders;
if (x.network) {
j["network"] = x.network;
}
if (x.resources) {
j["resources"] = x.resources;
}
if (x.servicing) {
j["servicing"] = x.servicing;
}
}

inline void from_json(const json & j, ZosDevice& x) {
x.fileMode = get_stack_optional<int64_t>(j, "fileMode");
x.gid = get_stack_optional<int64_t>(j, "gid");
x.major = j.at("major").get<int64_t>();
x.minor = j.at("minor").get<int64_t>();
x.path = j.at("path").get<std::string>();
x.type = j.at("type").get<std::string>();
x.uid = get_stack_optional<int64_t>(j, "uid");
}

inline void to_json(json & j, const ZosDevice & x) {
j = json::object();
if (x.fileMode) {
j["fileMode"] = x.fileMode;
}
if (x.gid) {
j["gid"] = x.gid;
}
j["major"] = x.major;
j["minor"] = x.minor;
j["path"] = x.path;
j["type"] = x.type;
if (x.uid) {
j["uid"] = x.uid;
}
}

inline void from_json(const json & j, Zos& x) {
x.devices = get_stack_optional<std::vector<ZosDevice>>(j, "devices");
}

inline void to_json(json & j, const Zos & x) {
j = json::object();
if (x.devices) {
j["devices"] = x.devices;
}
}

inline void from_json(const json & j, Config& x) {
x.annotations = get_stack_optional<std::map<std::string, std::string>>(j, "annotations");
x.domainname = get_stack_optional<std::string>(j, "domainname");
x.hooks = get_stack_optional<Hooks>(j, "hooks");
x.hostname = get_stack_optional<std::string>(j, "hostname");
x.linux_ = get_stack_optional<Linux>(j, "linux");
x.mounts = get_stack_optional<std::vector<Mount>>(j, "mounts");
x.ociVersion = j.at("ociVersion").get<std::string>();
x.process = get_stack_optional<Process>(j, "process");
x.root = get_stack_optional<Root>(j, "root");
x.solaris = get_stack_optional<Solaris>(j, "solaris");
x.vm = get_stack_optional<Vm>(j, "vm");
x.windows = get_stack_optional<Windows>(j, "windows");
x.zos = get_stack_optional<Zos>(j, "zos");
}

inline void to_json(json & j, const Config & x) {
j = json::object();
if (x.annotations) {
j["annotations"] = x.annotations;
}
if (x.domainname) {
j["domainname"] = x.domainname;
}
if (x.hooks) {
j["hooks"] = x.hooks;
}
if (x.hostname) {
j["hostname"] = x.hostname;
}
if (x.linux_) {
j["linux"] = x.linux_;
}
if (x.mounts) {
j["mounts"] = x.mounts;
}
j["ociVersion"] = x.ociVersion;
if (x.process) {
j["process"] = x.process;
}
if (x.root) {
j["root"] = x.root;
}
if (x.solaris) {
j["solaris"] = x.solaris;
}
if (x.vm) {
j["vm"] = x.vm;
}
if (x.windows) {
j["windows"] = x.windows;
}
if (x.zos) {
j["zos"] = x.zos;
}
}

inline void from_json(const json & j, NamespaceType & x) {
if (j == "cgroup") x = NamespaceType::Cgroup;
else if (j == "ipc") x = NamespaceType::Ipc;
else if (j == "mount") x = NamespaceType::Mount;
else if (j == "network") x = NamespaceType::Network;
else if (j == "pid") x = NamespaceType::Pid;
else if (j == "time") x = NamespaceType::Time;
else if (j == "user") x = NamespaceType::User;
else if (j == "uts") x = NamespaceType::Uts;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const NamespaceType & x) {
switch (x) {
case NamespaceType::Cgroup: j = "cgroup"; break;
case NamespaceType::Ipc: j = "ipc"; break;
case NamespaceType::Mount: j = "mount"; break;
case NamespaceType::Network: j = "network"; break;
case NamespaceType::Pid: j = "pid"; break;
case NamespaceType::Time: j = "time"; break;
case NamespaceType::User: j = "user"; break;
case NamespaceType::Uts: j = "uts"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, PersonalityDomain & x) {
if (j == "LINUX") x = PersonalityDomain::Linux;
else if (j == "LINUX32") x = PersonalityDomain::Linux32;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const PersonalityDomain & x) {
switch (x) {
case PersonalityDomain::Linux: j = "LINUX"; break;
case PersonalityDomain::Linux32: j = "LINUX32"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, RootfsPropagation & x) {
if (j == "private") x = RootfsPropagation::Private;
else if (j == "shared") x = RootfsPropagation::Shared;
else if (j == "slave") x = RootfsPropagation::Slave;
else if (j == "unbindable") x = RootfsPropagation::Unbindable;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const RootfsPropagation & x) {
switch (x) {
case RootfsPropagation::Private: j = "private"; break;
case RootfsPropagation::Shared: j = "shared"; break;
case RootfsPropagation::Slave: j = "slave"; break;
case RootfsPropagation::Unbindable: j = "unbindable"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, SeccompArch & x) {
static std::unordered_map<std::string, SeccompArch> enumValues {
{"SCMP_ARCH_AARCH64", SeccompArch::ScmpArchAarch64},
{"SCMP_ARCH_ARM", SeccompArch::ScmpArchArm},
{"SCMP_ARCH_MIPS", SeccompArch::ScmpArchMIPS},
{"SCMP_ARCH_MIPS64", SeccompArch::ScmpArchMips64},
{"SCMP_ARCH_MIPS64N32", SeccompArch::ScmpArchMips64N32},
{"SCMP_ARCH_MIPSEL", SeccompArch::ScmpArchMipsel},
{"SCMP_ARCH_MIPSEL64", SeccompArch::ScmpArchMipsel64},
{"SCMP_ARCH_MIPSEL64N32", SeccompArch::ScmpArchMipsel64N32},
{"SCMP_ARCH_PPC", SeccompArch::ScmpArchPPC},
{"SCMP_ARCH_PARISC", SeccompArch::ScmpArchParisc},
{"SCMP_ARCH_PARISC64", SeccompArch::ScmpArchParisc64},
{"SCMP_ARCH_PPC64", SeccompArch::ScmpArchPpc64},
{"SCMP_ARCH_PPC64LE", SeccompArch::ScmpArchPpc64LE},
{"SCMP_ARCH_RISCV64", SeccompArch::ScmpArchRiscv64},
{"SCMP_ARCH_S390", SeccompArch::ScmpArchS390},
{"SCMP_ARCH_S390X", SeccompArch::ScmpArchS390X},
{"SCMP_ARCH_X32", SeccompArch::ScmpArchX32},
{"SCMP_ARCH_X86", SeccompArch::ScmpArchX86},
{"SCMP_ARCH_X86_64", SeccompArch::ScmpArchX8664},
};
auto iter = enumValues.find(j.get<std::string>());
if (iter != enumValues.end()) {
x = iter->second;
}
}

inline void to_json(json & j, const SeccompArch & x) {
switch (x) {
case SeccompArch::ScmpArchAarch64: j = "SCMP_ARCH_AARCH64"; break;
case SeccompArch::ScmpArchArm: j = "SCMP_ARCH_ARM"; break;
case SeccompArch::ScmpArchMIPS: j = "SCMP_ARCH_MIPS"; break;
case SeccompArch::ScmpArchMips64: j = "SCMP_ARCH_MIPS64"; break;
case SeccompArch::ScmpArchMips64N32: j = "SCMP_ARCH_MIPS64N32"; break;
case SeccompArch::ScmpArchMipsel: j = "SCMP_ARCH_MIPSEL"; break;
case SeccompArch::ScmpArchMipsel64: j = "SCMP_ARCH_MIPSEL64"; break;
case SeccompArch::ScmpArchMipsel64N32: j = "SCMP_ARCH_MIPSEL64N32"; break;
case SeccompArch::ScmpArchPPC: j = "SCMP_ARCH_PPC"; break;
case SeccompArch::ScmpArchParisc: j = "SCMP_ARCH_PARISC"; break;
case SeccompArch::ScmpArchParisc64: j = "SCMP_ARCH_PARISC64"; break;
case SeccompArch::ScmpArchPpc64: j = "SCMP_ARCH_PPC64"; break;
case SeccompArch::ScmpArchPpc64LE: j = "SCMP_ARCH_PPC64LE"; break;
case SeccompArch::ScmpArchRiscv64: j = "SCMP_ARCH_RISCV64"; break;
case SeccompArch::ScmpArchS390: j = "SCMP_ARCH_S390"; break;
case SeccompArch::ScmpArchS390X: j = "SCMP_ARCH_S390X"; break;
case SeccompArch::ScmpArchX32: j = "SCMP_ARCH_X32"; break;
case SeccompArch::ScmpArchX86: j = "SCMP_ARCH_X86"; break;
case SeccompArch::ScmpArchX8664: j = "SCMP_ARCH_X86_64"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, SeccompAction & x) {
if (j == "SCMP_ACT_ALLOW") x = SeccompAction::ScmpActAllow;
else if (j == "SCMP_ACT_ERRNO") x = SeccompAction::ScmpActErrno;
else if (j == "SCMP_ACT_KILL") x = SeccompAction::ScmpActKill;
else if (j == "SCMP_ACT_KILL_PROCESS") x = SeccompAction::ScmpActKillProcess;
else if (j == "SCMP_ACT_KILL_THREAD") x = SeccompAction::ScmpActKillThread;
else if (j == "SCMP_ACT_LOG") x = SeccompAction::ScmpActLog;
else if (j == "SCMP_ACT_NOTIFY") x = SeccompAction::ScmpActNotify;
else if (j == "SCMP_ACT_TRACE") x = SeccompAction::ScmpActTrace;
else if (j == "SCMP_ACT_TRAP") x = SeccompAction::ScmpActTrap;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const SeccompAction & x) {
switch (x) {
case SeccompAction::ScmpActAllow: j = "SCMP_ACT_ALLOW"; break;
case SeccompAction::ScmpActErrno: j = "SCMP_ACT_ERRNO"; break;
case SeccompAction::ScmpActKill: j = "SCMP_ACT_KILL"; break;
case SeccompAction::ScmpActKillProcess: j = "SCMP_ACT_KILL_PROCESS"; break;
case SeccompAction::ScmpActKillThread: j = "SCMP_ACT_KILL_THREAD"; break;
case SeccompAction::ScmpActLog: j = "SCMP_ACT_LOG"; break;
case SeccompAction::ScmpActNotify: j = "SCMP_ACT_NOTIFY"; break;
case SeccompAction::ScmpActTrace: j = "SCMP_ACT_TRACE"; break;
case SeccompAction::ScmpActTrap: j = "SCMP_ACT_TRAP"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, SeccompFlag & x) {
if (j == "SECCOMP_FILTER_FLAG_LOG") x = SeccompFlag::SeccompFilterFlagLog;
else if (j == "SECCOMP_FILTER_FLAG_SPEC_ALLOW") x = SeccompFlag::SeccompFilterFlagSpecAllow;
else if (j == "SECCOMP_FILTER_FLAG_TSYNC") x = SeccompFlag::SeccompFilterFlagTsync;
else if (j == "SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV") x = SeccompFlag::SeccompFilterFlagWaitKillableRecv;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const SeccompFlag & x) {
switch (x) {
case SeccompFlag::SeccompFilterFlagLog: j = "SECCOMP_FILTER_FLAG_LOG"; break;
case SeccompFlag::SeccompFilterFlagSpecAllow: j = "SECCOMP_FILTER_FLAG_SPEC_ALLOW"; break;
case SeccompFlag::SeccompFilterFlagTsync: j = "SECCOMP_FILTER_FLAG_TSYNC"; break;
case SeccompFlag::SeccompFilterFlagWaitKillableRecv: j = "SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, SeccompOperators & x) {
if (j == "SCMP_CMP_EQ") x = SeccompOperators::ScmpCmpEq;
else if (j == "SCMP_CMP_GE") x = SeccompOperators::ScmpCmpGe;
else if (j == "SCMP_CMP_GT") x = SeccompOperators::ScmpCmpGt;
else if (j == "SCMP_CMP_LE") x = SeccompOperators::ScmpCmpLE;
else if (j == "SCMP_CMP_LT") x = SeccompOperators::ScmpCmpLt;
else if (j == "SCMP_CMP_MASKED_EQ") x = SeccompOperators::ScmpCmpMaskedEq;
else if (j == "SCMP_CMP_NE") x = SeccompOperators::ScmpCmpNe;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const SeccompOperators & x) {
switch (x) {
case SeccompOperators::ScmpCmpEq: j = "SCMP_CMP_EQ"; break;
case SeccompOperators::ScmpCmpGe: j = "SCMP_CMP_GE"; break;
case SeccompOperators::ScmpCmpGt: j = "SCMP_CMP_GT"; break;
case SeccompOperators::ScmpCmpLE: j = "SCMP_CMP_LE"; break;
case SeccompOperators::ScmpCmpLt: j = "SCMP_CMP_LT"; break;
case SeccompOperators::ScmpCmpMaskedEq: j = "SCMP_CMP_MASKED_EQ"; break;
case SeccompOperators::ScmpCmpNe: j = "SCMP_CMP_NE"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, Class & x) {
if (j == "IOPRIO_CLASS_BE") x = Class::IoprioClassBe;
else if (j == "IOPRIO_CLASS_IDLE") x = Class::IoprioClassIdle;
else if (j == "IOPRIO_CLASS_RT") x = Class::IoprioClassRt;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const Class & x) {
switch (x) {
case Class::IoprioClassBe: j = "IOPRIO_CLASS_BE"; break;
case Class::IoprioClassIdle: j = "IOPRIO_CLASS_IDLE"; break;
case Class::IoprioClassRt: j = "IOPRIO_CLASS_RT"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, SchedulerFlag & x) {
if (j == "SCHED_FLAG_DL_OVERRUN") x = SchedulerFlag::SchedFlagDLOverrun;
else if (j == "SCHED_FLAG_KEEP_PARAMS") x = SchedulerFlag::SchedFlagKeepParams;
else if (j == "SCHED_FLAG_KEEP_POLICY") x = SchedulerFlag::SchedFlagKeepPolicy;
else if (j == "SCHED_FLAG_RECLAIM") x = SchedulerFlag::SchedFlagReclaim;
else if (j == "SCHED_FLAG_RESET_ON_FORK") x = SchedulerFlag::SchedFlagResetOnFork;
else if (j == "SCHED_FLAG_UTIL_CLAMP_MAX") x = SchedulerFlag::SchedFlagUtilClampMax;
else if (j == "SCHED_FLAG_UTIL_CLAMP_MIN") x = SchedulerFlag::SchedFlagUtilClampMin;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const SchedulerFlag & x) {
switch (x) {
case SchedulerFlag::SchedFlagDLOverrun: j = "SCHED_FLAG_DL_OVERRUN"; break;
case SchedulerFlag::SchedFlagKeepParams: j = "SCHED_FLAG_KEEP_PARAMS"; break;
case SchedulerFlag::SchedFlagKeepPolicy: j = "SCHED_FLAG_KEEP_POLICY"; break;
case SchedulerFlag::SchedFlagReclaim: j = "SCHED_FLAG_RECLAIM"; break;
case SchedulerFlag::SchedFlagResetOnFork: j = "SCHED_FLAG_RESET_ON_FORK"; break;
case SchedulerFlag::SchedFlagUtilClampMax: j = "SCHED_FLAG_UTIL_CLAMP_MAX"; break;
case SchedulerFlag::SchedFlagUtilClampMin: j = "SCHED_FLAG_UTIL_CLAMP_MIN"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, SchedulerPolicy & x) {
if (j == "SCHED_BATCH") x = SchedulerPolicy::SchedBatch;
else if (j == "SCHED_DEADLINE") x = SchedulerPolicy::SchedDeadline;
else if (j == "SCHED_FIFO") x = SchedulerPolicy::SchedFIFO;
else if (j == "SCHED_ISO") x = SchedulerPolicy::SchedISO;
else if (j == "SCHED_IDLE") x = SchedulerPolicy::SchedIdle;
else if (j == "SCHED_OTHER") x = SchedulerPolicy::SchedOther;
else if (j == "SCHED_RR") x = SchedulerPolicy::SchedRr;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const SchedulerPolicy & x) {
switch (x) {
case SchedulerPolicy::SchedBatch: j = "SCHED_BATCH"; break;
case SchedulerPolicy::SchedDeadline: j = "SCHED_DEADLINE"; break;
case SchedulerPolicy::SchedFIFO: j = "SCHED_FIFO"; break;
case SchedulerPolicy::SchedISO: j = "SCHED_ISO"; break;
case SchedulerPolicy::SchedIdle: j = "SCHED_IDLE"; break;
case SchedulerPolicy::SchedOther: j = "SCHED_OTHER"; break;
case SchedulerPolicy::SchedRr: j = "SCHED_RR"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, RootImageFormat & x) {
if (j == "qcow2") x = RootImageFormat::Qcow2;
else if (j == "raw") x = RootImageFormat::Raw;
else if (j == "vdi") x = RootImageFormat::Vdi;
else if (j == "vhd") x = RootImageFormat::Vhd;
else if (j == "vmdk") x = RootImageFormat::Vmdk;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const RootImageFormat & x) {
switch (x) {
case RootImageFormat::Qcow2: j = "qcow2"; break;
case RootImageFormat::Raw: j = "raw"; break;
case RootImageFormat::Vdi: j = "vdi"; break;
case RootImageFormat::Vhd: j = "vhd"; break;
case RootImageFormat::Vmdk: j = "vmdk"; break;
default: throw std::runtime_error("This should not happen");
}
}

inline void from_json(const json & j, IdType & x) {
if (j == "class") x = IdType::Class;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const IdType & x) {
switch (x) {
case IdType::Class: j = "class"; break;
default: throw std::runtime_error("This should not happen");
}
}
}
}
}
}

// clang-format on
