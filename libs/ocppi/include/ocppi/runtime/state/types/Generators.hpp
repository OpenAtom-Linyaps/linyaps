// Thish file is generated by /tools/codegen
// DO NOT EDIT IT.

// clang-format off

//  To parse this JSON data, first install
//
//      json.hpp  https://github.com/nlohmann/json
//
//  Then include this file, and then do
//
//     Generators.hpp data = nlohmann::json::parse(jsonString);

#pragma once

#include <optional>
#include <nlohmann/json.hpp>
#include "ocppi/runtime/state/types/helper.hpp"

#include "ocppi/runtime/state/types/State.hpp"
#include "ocppi/runtime/state/types/Status.hpp"

namespace ocppi {
namespace runtime {
namespace state {
namespace types {
void from_json(const json & j, State & x);
void to_json(json & j, const State & x);

void from_json(const json & j, Status & x);
void to_json(json & j, const Status & x);

inline void from_json(const json & j, State& x) {
x.annotations = get_stack_optional<std::map<std::string, std::string>>(j, "annotations");
x.bundle = j.at("bundle").get<std::string>();
x.id = j.at("id").get<std::string>();
x.ociVersion = j.at("ociVersion").get<std::string>();
x.pid = get_stack_optional<int64_t>(j, "pid");
x.status = j.at("status").get<Status>();
}

inline void to_json(json & j, const State & x) {
j = json::object();
if (x.annotations) {
j["annotations"] = x.annotations;
}
j["bundle"] = x.bundle;
j["id"] = x.id;
j["ociVersion"] = x.ociVersion;
if (x.pid) {
j["pid"] = x.pid;
}
j["status"] = x.status;
}

inline void from_json(const json & j, Status & x) {
if (j == "created") x = Status::Created;
else if (j == "creating") x = Status::Creating;
else if (j == "running") x = Status::Running;
else if (j == "stopped") x = Status::Stopped;
else { throw std::runtime_error("Input JSON does not conform to schema!"); }
}

inline void to_json(json & j, const Status & x) {
switch (x) {
case Status::Created: j = "created"; break;
case Status::Creating: j = "creating"; break;
case Status::Running: j = "running"; break;
case Status::Stopped: j = "stopped"; break;
default: throw std::runtime_error("This should not happen");
}
}
}
}
}
}

// clang-format on
