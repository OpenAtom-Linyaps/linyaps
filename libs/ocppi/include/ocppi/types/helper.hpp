// Thish file is generated by /tools/codegen
// DO NOT EDIT IT.

// clang-format off

//  To parse this JSON data, first install
//
//      json.hpp  https://github.com/nlohmann/json
//
//  Then include this file, and then do
//
//     helper.hpp data = nlohmann::json::parse(jsonString);

#pragma once

#include <optional>
#include <nlohmann/json.hpp>

#include <sstream>

namespace ocppi {
namespace types {
using nlohmann::json;

#ifndef NLOHMANN_UNTYPED_ocppi_types_HELPER
#define NLOHMANN_UNTYPED_ocppi_types_HELPER
inline json get_untyped(const json & j, const char * property) {
if (j.find(property) != j.end()) {
return j.at(property).get<json>();
}
return json();
}

inline json get_untyped(const json & j, std::string property) {
return get_untyped(j, property.data());
}
#endif

#ifndef NLOHMANN_OPTIONAL_ocppi_types_HELPER
#define NLOHMANN_OPTIONAL_ocppi_types_HELPER
template <typename T>
inline std::shared_ptr<T> get_heap_optional(const json & j, const char * property) {
auto it = j.find(property);
if (it != j.end() && !it->is_null()) {
return j.at(property).get<std::shared_ptr<T>>();
}
return std::shared_ptr<T>();
}

template <typename T>
inline std::shared_ptr<T> get_heap_optional(const json & j, std::string property) {
return get_heap_optional<T>(j, property.data());
}
template <typename T>
inline std::optional<T> get_stack_optional(const json & j, const char * property) {
auto it = j.find(property);
if (it != j.end() && !it->is_null()) {
return j.at(property).get<std::optional<T>>();
}
return std::optional<T>();
}

template <typename T>
inline std::optional<T> get_stack_optional(const json & j, std::string property) {
return get_stack_optional<T>(j, property.data());
}
#endif
}
}

#ifndef NLOHMANN_OPT_HELPER
#define NLOHMANN_OPT_HELPER
namespace nlohmann {
template <typename T>
struct adl_serializer<std::shared_ptr<T>> {
static void to_json(json & j, const std::shared_ptr<T> & opt) {
if (!opt) j = nullptr; else j = *opt;
}

static std::shared_ptr<T> from_json(const json & j) {
if (j.is_null()) return std::make_shared<T>(); else return std::make_shared<T>(j.get<T>());
}
};
template <typename T>
struct adl_serializer<std::optional<T>> {
static void to_json(json & j, const std::optional<T> & opt) {
if (!opt) j = nullptr; else j = *opt;
}

static std::optional<T> from_json(const json & j) {
if (j.is_null()) return std::make_optional<T>(); else return std::make_optional<T>(j.get<T>());
}
};
}
#endif

// clang-format on
